<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Racing</title>
</head>
<body>

	<canvas id="gameCanvas" width="800" height="600"></canvas>

	<script>
		let canvas, canvasContext;

		let ballX = 75;
		let ballY = 75;
		let ballSpeedX = 5;
		let ballSpeedY = 7;

		const TRACK_W = 40;
		const TRACK_H = 40;
		const TRACK_GAP = 2;
		const TRACK_DRAW_WIDTH = TRACK_W - TRACK_GAP;
		const TRACK_DRAW_HEIGHT = TRACK_H - TRACK_GAP;
		const TRACK_COLS = 20;
		const TRACK_ROWS = 15;
		// const trackGrid = new Array(TRACK_COLS * TRACK_ROWS);
		const trackGrid = [ 
												1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
												1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
												1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
												1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
												1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,
												1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1,
												1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
												1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,
												1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
												1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
												1, 0, 2, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
												1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
												1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
												1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
												1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
											];

		let mouseX = 0, mouseY = 0, trackIndexUnderMouse = 0;

		function updateMousePos(evt){
			const rect = canvas.getBoundingClientRect();
			const htmlRoot = document.documentElement;

			mouseX = evt.clientX - rect.left - htmlRoot.scrollLeft;
			mouseY = evt.clientY - rect.top - htmlRoot.scrollTop;

			/*
				ballY = mouseX;
				ballX = mouseX;
				ballSpeedX = 4;
				ballSpeedY = -4;
			*/
		}

		function ballReset(){
			for(let row = 0; row < TRACK_ROWS; row++){
				for(let col = 0; col < TRACK_COLS; col++){
					const arrayIndex = rowColToArrayIndex(col, row); 
					if(trackGrid[arrayIndex] === 2){
						trackGrid[arrayIndex] = 0;
						ballX = col * TRACK_W;
						ballY = row * TRACK_H;
					}
				}
			}
		}

		window.onload = function() {
			canvas = document.getElementById('gameCanvas');
			canvasContext = canvas.getContext('2d');

			const framesPerSecond = 30;
			const framesUpdateInterval = 1000 / framesPerSecond;
			setInterval(updateAll, framesUpdateInterval);

			canvas.addEventListener('mousemove', updateMousePos)
			ballReset();
		}

		function updateAll(){
			moveAll();
			drawAll();
		}

		function ballMove(){
			ballX += ballSpeedX;
			ballY += ballSpeedY;

			if((ballX > canvas.width && ballSpeedX > 0.0) || (ballX < 0 && ballSpeedX < 0.0)){
				ballSpeedX *= -1;
			}
			if( ballY < 0 && ballSpeedY < 0.0){
				ballSpeedY *= -1;
			}
			else if(ballY > canvas.height){
				ballReset();
			}
		}

		function isTrackAtColRow(col, row){
			if( col >= 0 && col < TRACK_COLS &&
					row >= 0 && row < TRACK_ROWS){
				const trackIndexUnderCoord = rowColToArrayIndex(col, row);
				return (trackGrid[trackIndexUnderCoord] === 1);
			}
			return false;
		}

		function ballTrackHandling(){
			const ballTrackCol = Math.floor(ballX / TRACK_W);
			const ballTrackRow = Math.floor(ballY / TRACK_H);
			const trackIndexUnderBall = rowColToArrayIndex(ballTrackCol, ballTrackRow);

			if( 
					ballTrackCol >= 0 && ballTrackCol < TRACK_COLS &&
					ballTrackRow >= 0 && ballTrackRow < TRACK_ROWS
				 ){
				if(isTrackAtColRow(ballTrackCol, ballTrackRow)){

					const prevBallX = ballX - ballSpeedX;
					const prevBallY = ballY - ballSpeedY;
					const prevTrackCol = Math.floor(prevBallX / TRACK_W);
					const prevTrackRow = Math.floor(prevBallY / TRACK_H);

					let bothTestsFailed = true;

					if(prevTrackCol != ballTrackCol){
						if(isTrackAtColRow(prevTrackCol, prevTrackRow) === false){
							ballSpeedX *= -1;
							bothTestsFailed = false;
						}
					}
					if(prevTrackRow != ballTrackRow){
						if(isTrackAtColRow(ballTrackCol, prevTrackRow) === false){
							ballSpeedY *= -1;
							bothTestsFailed = false;
						}
					}

					if(bothTestsFailed){
							ballSpeedX *= -1;
							ballSpeedY *= -1;
					}

				} // end of track found
			} // end of valid col and row
		} 

		
		function moveAll(){
			// ballMove();
			ballTrackHandling();
		}

		function rowColToArrayIndex(col, row){
			return col + TRACK_COLS * row;
		}

		function drawTracks(){
			for(let row = 0; row < TRACK_ROWS; row++){
				for(let col = 0; col < TRACK_COLS; col++){
					const arrayIndex = rowColToArrayIndex(col, row); 
					if(trackGrid[arrayIndex] === 1){
						colorRect(TRACK_W*col,TRACK_H*row, TRACK_DRAW_WIDTH,TRACK_DRAW_HEIGHT, 'blue')
					}
				}
			}
		}

		function drawAll(){
			
			colorRect(0,0, canvas.width,canvas.height, 'black'); // clear screen
			colorCircle(ballX,ballY, 10, 'white'); // draw ball
			canvasContext.fill();


			drawTracks();

			/*if(trackIndexUnderMouse >= 0 &&
				 trackIndexUnderMouse <= TRACK_COLS * TRACK_ROWS){
				trackGrid[trackIndexUnderMouse] = false;
			}*/

			trackIndexUnderMouse = Math.floor(mouseX/TRACK_W) + Math.floor(mouseY/TRACK_H)*TRACK_COLS ;

			colorText(`${mouseX/TRACK_W}, ${mouseY/TRACK_H} : ${trackIndexUnderMouse}`, mouseX,mouseY, 'yellow');

		}

		function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor){
			canvasContext.fillStyle = fillColor;
			canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
		}

		function colorCircle(centerX,centerY, radius, fillColor){
			canvasContext.fillStyle = fillColor;
			canvasContext.beginPath();
			canvasContext.arc(centerX,centerY, radius, 0, Math.PI*2, true); // cx, cy, radius, from 0 to 360 deg, clockwise
		}

		function colorText(showWords, textX,textY, fillColor){
			canvasContext.fillStyle = fillColor;
			canvasContext.fillText(showWords, textX,textY);
		}

	</script>
</body>
</html>
